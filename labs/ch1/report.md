# ch1

完成时间: 2024-09-11

## Q1: 应用程序在执行过程中，会占用哪些计算机资源?

常规的应用程序一般只占用内存、CPU两个资源，并且所有的应用程序都要占用这两个资源。但是一些需要设备支持的应用程序，例如访问时钟，访问存储设备，可能需要硬件时钟、存储设备的支持。

## Q2: 请用相关工具软件分析并给出应用程序A的代码段/数据段/堆/栈的地址空间范围

可以使用`readelf`工具进行查看，结果如下

```shell
Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [12] .init             PROGBITS         0000000000001000  00001000
       000000000000001b  0000000000000000  AX       0     0     4
  [13] .plt              PROGBITS         0000000000001020  00001020
       0000000000000060  0000000000000010  AX       0     0     16
  [14] .plt.got          PROGBITS         0000000000001080  00001080
       0000000000000010  0000000000000010  AX       0     0     16
  [15] .plt.sec          PROGBITS         0000000000001090  00001090
       0000000000000050  0000000000000010  AX       0     0     16
  [16] .text             PROGBITS         00000000000010e0  000010e0
       0000000000000173  0000000000000000  AX       0     0     16
  [17] .fini             PROGBITS         0000000000001254  00001254
       000000000000000d  0000000000000000  AX       0     0     4
  [18] .rodata           PROGBITS         0000000000002000  00002000
       000000000000001d  0000000000000000   A       0     0     4
  [19] .eh_frame_hdr     PROGBITS         0000000000002020  00002020
       0000000000000034  0000000000000000   A       0     0     4
  [20] .eh_frame         PROGBITS         0000000000002058  00002058
       00000000000000ac  0000000000000000   A       0     0     8
  [21] .init_array       INIT_ARRAY       0000000000003d98  00002d98
       0000000000000008  0000000000000008  WA       0     0     8
  [22] .fini_array       FINI_ARRAY       0000000000003da0  00002da0
       0000000000000008  0000000000000008  WA       0     0     8
  [23] .dynamic          DYNAMIC          0000000000003da8  00002da8
       00000000000001f0  0000000000000010  WA       7     0     8
  [24] .got              PROGBITS         0000000000003f98  00002f98
       0000000000000068  0000000000000008  WA       0     0     8
  [25] .data             PROGBITS         0000000000004000  00003000
       0000000000000010  0000000000000000  WA       0     0     8
```

可以看到`.text`代码段的地址位于`0x00000000000010e0`, 长度为`0x0000000000000173`.
`.data`数据段的地址位于`0x0000000000004000`, 长度为`0x0000000000000010`
堆区和栈区是运行时分配的，可以在程序A运行的时候使用下列命令查看

```shell
cat /proc/pid/maps
```

也可以通过gdb查看

```gdb
info proc mappings
```

## 请简要说明应用程序与操作系统的异同之处

应用程序可以调用标准库去实现一些功能，而操作系统并没有这些库，在实现一个bare-metal的os的时候，可能需要去除掉标准库，然后自己实现相关函数，比如printf，malloc等。在硬件上，OS工作在比应用程序更高特权等级的异常等级上，意味着操作系统有更多的硬件功能可以使用。

## 请基于QEMU模拟RISC—V的执行过程和QEMU源代码，说明RISC-V硬件加电后的几条指令在哪里？完成了哪些功能？

// pass

## 为了让应用程序能在计算机上执行，操作系统与编译器之间需要达成哪些协议？

需要OS知道编译器是如何组织程序的，比如代码段、数据段等。这样os才可以映射相关内存。同时编译器需要知道OS的ABI是怎么做的。这样才能提供相应的syscall服务。

## 为何应用程序员编写应用时不需要建立栈空间和指定地址空间？

OS完成了，应用程序员不关注

## 现代的很多编译器生成的代码，默认情况下不再严格保存/恢复栈帧指针。在这个情况下，我们只要编译器提供足够的信息，也可以完成对调用栈的恢复

1. 可以根据pc和符号表判断当前所在函数。
2. 此时pc = 0x10752, 处于flip函数开头，所以sp为flap函数的sp。
3. 根据ra可以判断，返回地址位于flap

因此这是一次flap call flip的操作。

可以恢复两个调用的信息， 一个是当前的，另外一个是返回的。

# 实验问答

## 通过 gdb 简单跟踪从机器加电到跳转到 0x80200000 的简单过程。只需要描述重要的跳转即可，只需要描述在 qemu 上的情况

通过`Makefile`中提前写好的命令启动GDB调试，可以看到上电后的pc位于`0x1000`处，然后查看此处的10条指令

```GDB
x/10i 0x1000
```

结果如下所示

```GDB
(gdb) x/10i 0x1000
=> 0x1000:      auipc   t0,0x0
   0x1004:      addi    a2,t0,40
   0x1008:      csrr    a0,mhartid
   0x100c:      ld      a1,32(t0)
   0x1010:      ld      t0,24(t0)
   0x1014:      jr      t0
   0x1018:      unimp
   0x101a:      0x8000
   0x101c:      unimp
   0x101e:      unimp
```

其中umimp是指未实现的指令。一条条指令分析，其中

1. auipc: 将pc的高20位送入和0x0相加送入t0，此时pc = 0x1000。执行完该条指令的CPU状态为 t0 = 0x1000
2. t0 加上40 送入a2, 此时a2 = 0x1028
3. csrr读取硬件线程id
4. 读取t0偏移32B的数据到a1， addr = 0x1000 + 0d32 = 0x1020
5. 读取t0偏移24B的数据到t0， addr = 0x1000 + 0d24 = 0x1018，从源码上来看，这段序列之后是fdt数据。但是通过gdb可以知道，0x1010处这条指令执行完以后t0 = 0x80000000，即rustsbi的位置
6. 跳转到t0，addr = 0x80000000，即跳转到rustsbi。
